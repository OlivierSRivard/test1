# File: pages/01_Company_Search.py
# Runs on Parquet only (companies.parquet, categories.parquet)

from __future__ import annotations

import streamlit as st
import pandas as pd
from pathlib import Path

# Hide sidebar/nav and block page if not authed
if not st.session_state.get("is_authed"):
    st.markdown("""
        <style>
            [data-testid="stSidebar"] {display:none !important;}
            [data-testid="stSidebarNav"] {display:none !important;}
            [data-testid="collapsedControl"] {display:none !important;}
        </style>
    """, unsafe_allow_html=True)

    # If Streamlit supports switch_page in your version, you can redirect:
    try:
        from streamlit.runtime.scriptrunner import add_script_run_ctx  # just to probe internal API
        st.switch_page("Home.py")  # works in recent Streamlit versions
    except Exception:
        st.stop()  # hard stop if switch_page isn't available
# --- Page setup ---
st.set_page_config(page_title="Company Search", page_icon="ðŸ”Ž", layout="wide")
st.title("Search Companies in Ecosystem")

DATA_DIR = Path("data")
COMPQ = DATA_DIR / "companies.parquet"
CATQ  = DATA_DIR / "categories.parquet"

# ---------------------------
# Load data (Parquet only)
# ---------------------------
@st.cache_data(show_spinner=False)
def load_data_fast():
    """
    Load data from Parquet generated by tools/convert_fintech_excel_to_parquet.py
    Returns:
      details_by_name, df_ds2 (cats), link_by_name,
      team_to_functions, function_to_subs,
      teams_list, functions_list, subfunctions_list
    """
    if not (COMPQ.exists() and CATQ.exists()):
        raise FileNotFoundError(
            "Parquet data not found. Run once:\n"
            "  python tools/convert_fintech_excel_to_parquet.py\n"
            "This produces data/companies.parquet and data/categories.parquet."
        )

    companies = pd.read_parquet(COMPQ)
    cats = pd.read_parquet(CATQ)

    # Build dictionaries used by the UI
    details_by_name: dict[str, dict] = {}
    link_by_name: dict[str, str] = {}

    for _, r in companies.iterrows():
        nm = str(r["Name"]).strip()
        details_by_name[nm] = {
            "Creation": r.get("Creation", ""),
            "Employees": r.get("Employees", ""),
            "Funding ($m)": r.get("Funding ($m)", ""),
            "Country": r.get("Country", "") or "",
            "Notes": r.get("Notes", "") or "",
            "Description": r.get("Description", "") or "",
        }
        link_by_name[nm] = r.get("Website", "") or ""

    # Normalize types/whitespace for filters
    for c in ["Team", "Function", "Subfunction", "Name"]:
        if c in cats.columns:
            cats[c] = cats[c].astype(str).str.strip()

    teams_list      = sorted(cats["Team"].dropna().unique().tolist())
    functions_list  = sorted(cats["Function"].dropna().unique().tolist())
    subfunctions_list = sorted(cats["Subfunction"].dropna().unique().tolist())

    team_to_functions = {
        t: sorted(cats.loc[cats["Team"] == t, "Function"].dropna().unique().tolist())
        for t in teams_list
    }
    function_to_subs = {
        f: sorted(cats.loc[cats["Function"] == f, "Subfunction"].dropna().unique().tolist())
        for f in functions_list
    }

    return (
        details_by_name, cats, link_by_name,
        team_to_functions, function_to_subs,
        teams_list, functions_list, subfunctions_list
    )

# Load data (stop with a helpful error if parquet missing)
try:
    (details_by_name, df_ds2, link_by_name,
     team_to_functions, function_to_subs,
     teams_list, functions_list, subfunctions_list) = load_data_fast()
except Exception as e:
    st.error(f"Failed to load cached data: {e}")
    st.stop()

# ---------------------------
# Helpers for interactive tables
# ---------------------------
def _logo_url_from_link(url: str) -> str:
    try:
        from urllib.parse import urlparse
        domain = urlparse(url).netloc or ""
        domain = domain.lstrip("www.")
        return f"https://logo.clearbit.com/{domain}" if domain else ""
    except Exception:
        return ""

def build_results_df(result_names, include_categories=False, categories_by_name=None):
    """Construct a typed DataFrame for display with st.dataframe."""
    rows = []
    for name in sorted(result_names):
        info = details_by_name.get(name, {})
        website = link_by_name.get(name, "")
        rows.append({
            "Logo": _logo_url_from_link(website) if website else "",
            "Name": name,
            "Website": website,
            "Creation": info.get("Creation", ""),
            "Employees": info.get("Employees", ""),
            "Funding ($m)": info.get("Funding ($m)", ""),
            "Country": info.get("Country", ""),
            "Notes": info.get("Notes", ""),
            "Description": info.get("Description", ""),
            **({
                "Teams": (categories_by_name.get(name, {}).get("teams", "") if categories_by_name else ""),
                "Functions": (categories_by_name.get(name, {}).get("functions", "") if categories_by_name else ""),
                "Subfunctions": (categories_by_name.get(name, {}).get("subfunctions", "") if categories_by_name else "")
            } if include_categories else {})
        })
    df = pd.DataFrame(rows)

    # Coerce numeric columns so sorting works correctly
    for col in ["Creation", "Employees", "Funding ($m)"]:
        if col in df.columns:
            df[col] = pd.to_numeric(df[col], errors="coerce")

    # Normalize empty countries to None for nicer filtering
    if "Country" in df.columns:
        df["Country"] = df["Country"].replace({"": None})

    return df

def render_results_df(df: pd.DataFrame, *, show_categories: bool = False, min_visible_rows: int = 50):
    """Add a Country filter and render a sortable, interactive table."""
    if "Country" in df.columns:
        countries = sorted([c for c in df["Country"].dropna().unique().tolist() if str(c).strip() != ""])
        if countries:
            selected_countries = st.multiselect("Filter by Country", options=countries, default=countries)
            df = df[df["Country"].isin(selected_countries)]

    column_config = {
        "Logo": st.column_config.ImageColumn("Logo", width="small"),
        "Website": st.column_config.LinkColumn("Website"),
        "Creation": st.column_config.NumberColumn("Creation", help="Year of creation"),
        "Employees": st.column_config.NumberColumn("Employees"),
        "Funding ($m)": st.column_config.NumberColumn("Funding ($m)"),
        "Notes": st.column_config.TextColumn("Notes"),
        "Description": st.column_config.TextColumn("Description"),
        "Name": st.column_config.TextColumn("Name"),
        "Country": st.column_config.TextColumn("Country"),
    }

    display_cols = ["Logo", "Name", "Website", "Creation", "Employees", "Funding ($m)", "Country", "Notes", "Description"]
    if show_categories:
        display_cols += ["Teams", "Functions", "Subfunctions"]
        column_config.update({
            "Teams": st.column_config.TextColumn("Teams"),
            "Functions": st.column_config.TextColumn("Functions"),
            "Subfunctions": st.column_config.TextColumn("Subfunctions"),
        })

    # Make the component tall enough so the page scrolls (not the grid)
    n_rows = len(df)
    rows_to_show = max(1, min(n_rows, min_visible_rows))
    ROW_PX = 37
    HEADER_PX = 38
    PADDING_PX = 16
    height = HEADER_PX + ROW_PX * rows_to_show + PADDING_PX

    st.dataframe(
        df[display_cols],
        hide_index=True,
        width='stretch',
        column_config=column_config,
        height=height,
    )

# ---------------------------
# UI: Search modes
# ---------------------------
search_mode = st.radio(
    "Search by",
    ["Functional Categories", "Company Name", "Keyword"],  # Functional first
    index=0,  # default to Functional Categories
)

if search_mode == "Functional Categories":
    st.write("**Filter by functional classification:**")

    selected_teams = st.multiselect("Team", options=teams_list, default=[])
    if selected_teams:
        valid_functions = sorted({f for t in selected_teams for f in team_to_functions.get(t, [])})
    else:
        valid_functions = functions_list
    selected_functions = st.multiselect("Function", options=valid_functions, default=[])

    if selected_functions:
        sub_opts = sorted({s for f in selected_functions for s in function_to_subs.get(f, [])})
    elif selected_teams:
        sub_opts = sorted({s for t in selected_teams for f in team_to_functions.get(t, []) for s in function_to_subs.get(f, [])})
    else:
        sub_opts = subfunctions_list
    selected_subfunctions = st.multiselect("Subfunction", options=sub_opts, default=[])

    if not selected_teams and not selected_functions and not selected_subfunctions:
        filtered_df = df_ds2.copy()
    else:
        filtered_df = df_ds2.copy()
        if selected_teams:
            filtered_df = filtered_df[filtered_df["Team"].isin(selected_teams)]
        if selected_functions:
            filtered_df = filtered_df[filtered_df["Function"].isin(selected_functions)]
        if selected_subfunctions:
            filtered_df = filtered_df[filtered_df["Subfunction"].isin(selected_subfunctions)]

    result_names = filtered_df["Name"].unique().tolist()
    st.caption(f"Found {len(result_names)} matching company(s)")
    if not result_names:
        st.info("No companies match the selected criteria.")
    else:
        agg = filtered_df.groupby("Name").agg(
            teams=('Team', lambda x: ", ".join(sorted({str(v).strip() for v in x.dropna() if str(v).strip() != ""})) ),
            functions=('Function', lambda x: ", ".join(sorted({str(v).strip() for v in x.dropna() if str(v).strip() != ""})) ),
            subfunctions=('Subfunction', lambda x: ", ".join(sorted({str(v).strip() for v in x.dropna() if str(v).strip() != ""})) ),
        ).reset_index()
        categories_by_name = {
            r["Name"]: {"teams": r["teams"], "functions": r["functions"], "subfunctions": r["subfunctions"]}
            for _, r in agg.iterrows()
        }
        df_results = build_results_df(result_names, include_categories=True, categories_by_name=categories_by_name)
        render_results_df(df_results, show_categories=True)

elif search_mode == "Company Name":
    firm_query = st.text_input("Enter part of the company name (case-insensitive):").strip()
    if firm_query:
        q = firm_query.lower()
        result_names = [name for name in details_by_name.keys() if q in name.lower()]
        st.caption(f"Found {len(result_names)} matching firm(s)")
        if not result_names:
            st.info("No companies found. Try a different name or spelling.")
        else:
            df_results = build_results_df(result_names, include_categories=False)
            render_results_df(df_results, show_categories=False)

elif search_mode == "Keyword":
    st.write("**Search company descriptions for keywords:**")
    c1, c2 = st.columns(2)
    term1 = c1.text_input("Keyword 1:").strip()
    term2 = c2.text_input("Keyword 2 (optional):").strip()
    if term1 or term2:
        terms = [t.lower() for t in [term1, term2] if t]
        result_names = []
        for name, info in details_by_name.items():
            desc = (info.get("Description", "") or "").lower()
            if any(t in desc for t in terms):
                result_names.append(name)
        st.caption(f"Found {len(result_names)} matching company(s)")
        if not result_names:
            st.info("No companies found for those keywords.")
        else:
            df_results = build_results_df(result_names, include_categories=False)
            render_results_df(df_results, show_categories=False)
